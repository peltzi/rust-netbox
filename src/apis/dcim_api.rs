/*
 * NetBox API
 *
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.7
 *
 * Generated by: https://openapi-generator.tech
 */

use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;
use std::rc::Rc;

use reqwest;

use super::{configuration, Error};

pub struct DcimApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl DcimApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> DcimApiClient {
        DcimApiClient { configuration }
    }
}

pub trait DcimApi {
    fn dcim_cables_create(
        &self,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error>;
    fn dcim_cables_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_cables_list(
        &self,
        id: Option<&str>,
        label: Option<&str>,
        length: Option<&str>,
        length_unit: Option<&str>,
        q: Option<&str>,
        _type: Option<&str>,
        status: Option<&str>,
        color: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        rack_id: Option<&str>,
        rack: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2004, Error>;
    fn dcim_cables_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error>;
    fn dcim_cables_read(&self, id: i32) -> Result<crate::models::Cable, Error>;
    fn dcim_cables_update(
        &self,
        id: i32,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error>;
    fn dcim_choices_list(&self) -> Result<(), Error>;
    fn dcim_choices_read(&self, id: &str) -> Result<(), Error>;
    fn dcim_connected_device_list(
        &self,
        peer_device: &str,
        peer_interface: &str,
    ) -> Result<crate::models::Device, Error>;
    fn dcim_console_connections_list(
        &self,
        name: Option<&str>,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2005, Error>;
    fn dcim_console_port_templates_create(
        &self,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error>;
    fn dcim_console_port_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_console_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2006, Error>;
    fn dcim_console_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error>;
    fn dcim_console_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsolePortTemplate, Error>;
    fn dcim_console_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error>;
    fn dcim_console_ports_create(
        &self,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error>;
    fn dcim_console_ports_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_console_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2005, Error>;
    fn dcim_console_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error>;
    fn dcim_console_ports_read(&self, id: i32) -> Result<crate::models::ConsolePort, Error>;
    fn dcim_console_ports_trace(&self, id: i32) -> Result<crate::models::ConsolePort, Error>;
    fn dcim_console_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error>;
    fn dcim_console_server_port_templates_create(
        &self,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error>;
    fn dcim_console_server_port_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_console_server_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2007, Error>;
    fn dcim_console_server_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error>;
    fn dcim_console_server_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error>;
    fn dcim_console_server_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error>;
    fn dcim_console_server_ports_create(
        &self,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error>;
    fn dcim_console_server_ports_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_console_server_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2008, Error>;
    fn dcim_console_server_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error>;
    fn dcim_console_server_ports_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPort, Error>;
    fn dcim_console_server_ports_trace(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPort, Error>;
    fn dcim_console_server_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error>;
    fn dcim_device_bay_templates_create(
        &self,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error>;
    fn dcim_device_bay_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_device_bay_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2009, Error>;
    fn dcim_device_bay_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error>;
    fn dcim_device_bay_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::DeviceBayTemplate, Error>;
    fn dcim_device_bay_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error>;
    fn dcim_device_bays_create(
        &self,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error>;
    fn dcim_device_bays_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_device_bays_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20010, Error>;
    fn dcim_device_bays_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error>;
    fn dcim_device_bays_read(&self, id: i32) -> Result<crate::models::DeviceBay, Error>;
    fn dcim_device_bays_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error>;
    fn dcim_device_roles_create(
        &self,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error>;
    fn dcim_device_roles_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_device_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        color: Option<&str>,
        vm_role: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20011, Error>;
    fn dcim_device_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error>;
    fn dcim_device_roles_read(&self, id: i32) -> Result<crate::models::DeviceRole, Error>;
    fn dcim_device_roles_update(
        &self,
        id: i32,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error>;
    fn dcim_device_types_create(
        &self,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error>;
    fn dcim_device_types_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_device_types_list(
        &self,
        model: Option<&str>,
        slug: Option<&str>,
        part_number: Option<&str>,
        u_height: Option<&str>,
        is_full_depth: Option<&str>,
        subdevice_role: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        console_ports: Option<&str>,
        console_server_ports: Option<&str>,
        power_ports: Option<&str>,
        power_outlets: Option<&str>,
        interfaces: Option<&str>,
        pass_through_ports: Option<&str>,
        device_bays: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20012, Error>;
    fn dcim_device_types_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error>;
    fn dcim_device_types_read(&self, id: i32) -> Result<crate::models::DeviceType, Error>;
    fn dcim_device_types_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error>;
    fn dcim_devices_create(
        &self,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error>;
    fn dcim_devices_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_devices_graphs(&self, id: i32)
        -> Result<crate::models::DeviceWithConfigContext, Error>;
    fn dcim_devices_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        asset_tag: Option<&str>,
        face: Option<&str>,
        position: Option<&str>,
        vc_position: Option<&str>,
        vc_priority: Option<&str>,
        local_context_data: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        device_type_id: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        platform_id: Option<&str>,
        platform: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        rack_group_id: Option<&str>,
        rack_id: Option<&str>,
        cluster_id: Option<&str>,
        model: Option<&str>,
        status: Option<&str>,
        is_full_depth: Option<&str>,
        mac_address: Option<&str>,
        serial: Option<&str>,
        has_primary_ip: Option<&str>,
        virtual_chassis_id: Option<&str>,
        virtual_chassis_member: Option<&str>,
        console_ports: Option<&str>,
        console_server_ports: Option<&str>,
        power_ports: Option<&str>,
        power_outlets: Option<&str>,
        interfaces: Option<&str>,
        pass_through_ports: Option<&str>,
        device_bays: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20013, Error>;
    fn dcim_devices_napalm(
        &self,
        id: i32,
        method: &str,
    ) -> Result<crate::models::DeviceNapalm, Error>;
    fn dcim_devices_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error>;
    fn dcim_devices_read(&self, id: i32) -> Result<crate::models::DeviceWithConfigContext, Error>;
    fn dcim_devices_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error>;
    fn dcim_front_port_templates_create(
        &self,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error>;
    fn dcim_front_port_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_front_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20014, Error>;
    fn dcim_front_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error>;
    fn dcim_front_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::FrontPortTemplate, Error>;
    fn dcim_front_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error>;
    fn dcim_front_ports_create(
        &self,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error>;
    fn dcim_front_ports_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_front_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20015, Error>;
    fn dcim_front_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error>;
    fn dcim_front_ports_read(&self, id: i32) -> Result<crate::models::FrontPort, Error>;
    fn dcim_front_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error>;
    fn dcim_interface_connections_list(
        &self,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20016, Error>;
    fn dcim_interface_templates_create(
        &self,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error>;
    fn dcim_interface_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_interface_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        mgmt_only: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20017, Error>;
    fn dcim_interface_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error>;
    fn dcim_interface_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::InterfaceTemplate, Error>;
    fn dcim_interface_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error>;
    fn dcim_interfaces_create(
        &self,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_interfaces_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_interfaces_graphs(&self, id: i32) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_interfaces_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        connection_status: Option<&str>,
        _type: Option<&str>,
        enabled: Option<&str>,
        mtu: Option<&str>,
        mgmt_only: Option<&str>,
        mode: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        kind: Option<&str>,
        lag_id: Option<&str>,
        mac_address: Option<&str>,
        vlan_id: Option<&str>,
        vlan: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20018, Error>;
    fn dcim_interfaces_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_interfaces_read(&self, id: i32) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_interfaces_trace(&self, id: i32) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_interfaces_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error>;
    fn dcim_inventory_items_create(
        &self,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error>;
    fn dcim_inventory_items_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_inventory_items_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        part_id: Option<&str>,
        asset_tag: Option<&str>,
        discovered: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        parent_id: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        serial: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20019, Error>;
    fn dcim_inventory_items_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error>;
    fn dcim_inventory_items_read(&self, id: i32) -> Result<crate::models::InventoryItem, Error>;
    fn dcim_inventory_items_update(
        &self,
        id: i32,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error>;
    fn dcim_manufacturers_create(
        &self,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error>;
    fn dcim_manufacturers_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_manufacturers_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20020, Error>;
    fn dcim_manufacturers_partial_update(
        &self,
        id: i32,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error>;
    fn dcim_manufacturers_read(&self, id: i32) -> Result<crate::models::Manufacturer, Error>;
    fn dcim_manufacturers_update(
        &self,
        id: i32,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error>;
    fn dcim_platforms_create(
        &self,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error>;
    fn dcim_platforms_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_platforms_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        napalm_driver: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20021, Error>;
    fn dcim_platforms_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error>;
    fn dcim_platforms_read(&self, id: i32) -> Result<crate::models::Platform, Error>;
    fn dcim_platforms_update(
        &self,
        id: i32,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error>;
    fn dcim_power_connections_list(
        &self,
        name: Option<&str>,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20022, Error>;
    fn dcim_power_feeds_create(
        &self,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error>;
    fn dcim_power_feeds_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_feeds_list(
        &self,
        name: Option<&str>,
        status: Option<&str>,
        _type: Option<&str>,
        supply: Option<&str>,
        phase: Option<&str>,
        voltage: Option<&str>,
        amperage: Option<&str>,
        max_utilization: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        power_panel_id: Option<&str>,
        rack_id: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20023, Error>;
    fn dcim_power_feeds_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error>;
    fn dcim_power_feeds_read(&self, id: i32) -> Result<crate::models::PowerFeed, Error>;
    fn dcim_power_feeds_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error>;
    fn dcim_power_outlet_templates_create(
        &self,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error>;
    fn dcim_power_outlet_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_outlet_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        feed_leg: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20024, Error>;
    fn dcim_power_outlet_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error>;
    fn dcim_power_outlet_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::PowerOutletTemplate, Error>;
    fn dcim_power_outlet_templates_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error>;
    fn dcim_power_outlets_create(
        &self,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error>;
    fn dcim_power_outlets_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_outlets_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        feed_leg: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20025, Error>;
    fn dcim_power_outlets_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error>;
    fn dcim_power_outlets_read(&self, id: i32) -> Result<crate::models::PowerOutlet, Error>;
    fn dcim_power_outlets_trace(&self, id: i32) -> Result<crate::models::PowerOutlet, Error>;
    fn dcim_power_outlets_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error>;
    fn dcim_power_panels_create(
        &self,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error>;
    fn dcim_power_panels_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_panels_list(
        &self,
        name: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        rack_group_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20026, Error>;
    fn dcim_power_panels_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error>;
    fn dcim_power_panels_read(&self, id: i32) -> Result<crate::models::PowerPanel, Error>;
    fn dcim_power_panels_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error>;
    fn dcim_power_port_templates_create(
        &self,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error>;
    fn dcim_power_port_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        maximum_draw: Option<&str>,
        allocated_draw: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20027, Error>;
    fn dcim_power_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error>;
    fn dcim_power_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::PowerPortTemplate, Error>;
    fn dcim_power_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error>;
    fn dcim_power_ports_create(
        &self,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error>;
    fn dcim_power_ports_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_power_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        maximum_draw: Option<&str>,
        allocated_draw: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20022, Error>;
    fn dcim_power_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error>;
    fn dcim_power_ports_read(&self, id: i32) -> Result<crate::models::PowerPort, Error>;
    fn dcim_power_ports_trace(&self, id: i32) -> Result<crate::models::PowerPort, Error>;
    fn dcim_power_ports_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error>;
    fn dcim_rack_groups_create(
        &self,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error>;
    fn dcim_rack_groups_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_rack_groups_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20028, Error>;
    fn dcim_rack_groups_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error>;
    fn dcim_rack_groups_read(&self, id: i32) -> Result<crate::models::RackGroup, Error>;
    fn dcim_rack_groups_update(
        &self,
        id: i32,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error>;
    fn dcim_rack_reservations_create(
        &self,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error>;
    fn dcim_rack_reservations_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_rack_reservations_list(
        &self,
        created: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        rack_id: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        user_id: Option<&str>,
        user: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20029, Error>;
    fn dcim_rack_reservations_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error>;
    fn dcim_rack_reservations_read(&self, id: i32)
        -> Result<crate::models::RackReservation, Error>;
    fn dcim_rack_reservations_update(
        &self,
        id: i32,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error>;
    fn dcim_rack_roles_create(
        &self,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error>;
    fn dcim_rack_roles_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_rack_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        color: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20030, Error>;
    fn dcim_rack_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error>;
    fn dcim_rack_roles_read(&self, id: i32) -> Result<crate::models::RackRole, Error>;
    fn dcim_rack_roles_update(
        &self,
        id: i32,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error>;
    fn dcim_racks_create(
        &self,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error>;
    fn dcim_racks_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_racks_elevation(
        &self,
        id: i32,
        q: Option<&str>,
        face: Option<&str>,
        render: Option<&str>,
        unit_width: Option<i32>,
        unit_height: Option<i32>,
        legend_width: Option<i32>,
        exclude: Option<i32>,
        expand_devices: Option<bool>,
        include_images: Option<bool>,
    ) -> Result<Vec<crate::models::RackUnit>, Error>;
    fn dcim_racks_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        facility_id: Option<&str>,
        asset_tag: Option<&str>,
        _type: Option<&str>,
        width: Option<&str>,
        u_height: Option<&str>,
        desc_units: Option<&str>,
        outer_width: Option<&str>,
        outer_depth: Option<&str>,
        outer_unit: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        status: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        serial: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20031, Error>;
    fn dcim_racks_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error>;
    fn dcim_racks_read(&self, id: i32) -> Result<crate::models::Rack, Error>;
    fn dcim_racks_units(&self, id: i32) -> Result<crate::models::Rack, Error>;
    fn dcim_racks_update(
        &self,
        id: i32,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error>;
    fn dcim_rear_port_templates_create(
        &self,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error>;
    fn dcim_rear_port_templates_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_rear_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        positions: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20032, Error>;
    fn dcim_rear_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error>;
    fn dcim_rear_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::RearPortTemplate, Error>;
    fn dcim_rear_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error>;
    fn dcim_rear_ports_create(
        &self,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error>;
    fn dcim_rear_ports_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_rear_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        positions: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20033, Error>;
    fn dcim_rear_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error>;
    fn dcim_rear_ports_read(&self, id: i32) -> Result<crate::models::RearPort, Error>;
    fn dcim_rear_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error>;
    fn dcim_regions_create(
        &self,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error>;
    fn dcim_regions_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_regions_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        parent_id: Option<&str>,
        parent: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20034, Error>;
    fn dcim_regions_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error>;
    fn dcim_regions_read(&self, id: i32) -> Result<crate::models::Region, Error>;
    fn dcim_regions_update(
        &self,
        id: i32,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error>;
    fn dcim_sites_create(
        &self,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error>;
    fn dcim_sites_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_sites_graphs(&self, id: i32) -> Result<crate::models::Site, Error>;
    fn dcim_sites_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        facility: Option<&str>,
        asn: Option<&str>,
        latitude: Option<&str>,
        longitude: Option<&str>,
        contact_name: Option<&str>,
        contact_phone: Option<&str>,
        contact_email: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        status: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20035, Error>;
    fn dcim_sites_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error>;
    fn dcim_sites_read(&self, id: i32) -> Result<crate::models::Site, Error>;
    fn dcim_sites_update(
        &self,
        id: i32,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error>;
    fn dcim_virtual_chassis_create(
        &self,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error>;
    fn dcim_virtual_chassis_delete(&self, id: i32) -> Result<(), Error>;
    fn dcim_virtual_chassis_list(
        &self,
        id: Option<&str>,
        domain: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20036, Error>;
    fn dcim_virtual_chassis_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error>;
    fn dcim_virtual_chassis_read(&self, id: i32) -> Result<crate::models::VirtualChassis, Error>;
    fn dcim_virtual_chassis_update(
        &self,
        id: i32,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error>;
}

impl DcimApi for DcimApiClient {
    fn dcim_cables_create(
        &self,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_cables_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_cables_list(
        &self,
        id: Option<&str>,
        label: Option<&str>,
        length: Option<&str>,
        length_unit: Option<&str>,
        q: Option<&str>,
        _type: Option<&str>,
        status: Option<&str>,
        color: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        rack_id: Option<&str>,
        rack: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2004, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = label {
            req_builder = req_builder.query(&[("label", &s.to_string())]);
        }
        if let Some(ref s) = length {
            req_builder = req_builder.query(&[("length", &s.to_string())]);
        }
        if let Some(ref s) = length_unit {
            req_builder = req_builder.query(&[("length_unit", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = color {
            req_builder = req_builder.query(&[("color", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = rack_id {
            req_builder = req_builder.query(&[("rack_id", &s.to_string())]);
        }
        if let Some(ref s) = rack {
            req_builder = req_builder.query(&[("rack", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_cables_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_cables_read(&self, id: i32) -> Result<crate::models::Cable, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_cables_update(
        &self,
        id: i32,
        data: crate::models::WritableCable,
    ) -> Result<crate::models::Cable, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/cables/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_choices_list(&self) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/_choices/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_choices_read(&self, id: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/_choices/{id}/",
            configuration.base_path,
            id = crate::apis::urlencode(id)
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_connected_device_list(
        &self,
        peer_device: &str,
        peer_interface: &str,
    ) -> Result<crate::models::Device, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/connected-device/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("peer_device", &peer_device.to_string())]);
        req_builder = req_builder.query(&[("peer_interface", &peer_interface.to_string())]);
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_connections_list(
        &self,
        name: Option<&str>,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2005, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-connections/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_port_templates_create(
        &self,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-port-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_port_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_console_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2006, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-port-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsolePortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePortTemplate,
    ) -> Result<crate::models::ConsolePortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_create(
        &self,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-ports/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_console_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2005, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-ports/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_read(&self, id: i32) -> Result<crate::models::ConsolePort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_trace(&self, id: i32) -> Result<crate::models::ConsolePort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-ports/{id}/trace/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableConsolePort,
    ) -> Result<crate::models::ConsolePort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_port_templates_create(
        &self,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/",
            configuration.base_path
        );
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_port_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_console_server_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2007, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/",
            configuration.base_path
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPortTemplate,
    ) -> Result<crate::models::ConsoleServerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_create(
        &self,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-server-ports/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_console_server_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2008, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/console-server-ports/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_read(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_trace(
        &self,
        id: i32,
    ) -> Result<crate::models::ConsoleServerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-ports/{id}/trace/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_console_server_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableConsoleServerPort,
    ) -> Result<crate::models::ConsoleServerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/console-server-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bay_templates_create(
        &self,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-bay-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bay_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bay-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_device_bay_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse2009, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-bay-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bay_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bay-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bay_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::DeviceBayTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bay-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bay_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBayTemplate,
    ) -> Result<crate::models::DeviceBayTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bay-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bays_create(
        &self,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-bays/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bays_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bays/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_device_bays_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20010, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-bays/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bays_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bays/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bays_read(&self, id: i32) -> Result<crate::models::DeviceBay, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bays/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_bays_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceBay,
    ) -> Result<crate::models::DeviceBay, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-bays/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_roles_create(
        &self,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-roles/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_roles_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-roles/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_device_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        color: Option<&str>,
        vm_role: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20011, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-roles/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = color {
            req_builder = req_builder.query(&[("color", &s.to_string())]);
        }
        if let Some(ref s) = vm_role {
            req_builder = req_builder.query(&[("vm_role", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-roles/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_roles_read(&self, id: i32) -> Result<crate::models::DeviceRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-roles/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_roles_update(
        &self,
        id: i32,
        data: crate::models::DeviceRole,
    ) -> Result<crate::models::DeviceRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-roles/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_types_create(
        &self,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-types/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_types_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-types/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_device_types_list(
        &self,
        model: Option<&str>,
        slug: Option<&str>,
        part_number: Option<&str>,
        u_height: Option<&str>,
        is_full_depth: Option<&str>,
        subdevice_role: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        console_ports: Option<&str>,
        console_server_ports: Option<&str>,
        power_ports: Option<&str>,
        power_outlets: Option<&str>,
        interfaces: Option<&str>,
        pass_through_ports: Option<&str>,
        device_bays: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20012, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/device-types/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = model {
            req_builder = req_builder.query(&[("model", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = part_number {
            req_builder = req_builder.query(&[("part_number", &s.to_string())]);
        }
        if let Some(ref s) = u_height {
            req_builder = req_builder.query(&[("u_height", &s.to_string())]);
        }
        if let Some(ref s) = is_full_depth {
            req_builder = req_builder.query(&[("is_full_depth", &s.to_string())]);
        }
        if let Some(ref s) = subdevice_role {
            req_builder = req_builder.query(&[("subdevice_role", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer_id {
            req_builder = req_builder.query(&[("manufacturer_id", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer {
            req_builder = req_builder.query(&[("manufacturer", &s.to_string())]);
        }
        if let Some(ref s) = console_ports {
            req_builder = req_builder.query(&[("console_ports", &s.to_string())]);
        }
        if let Some(ref s) = console_server_ports {
            req_builder = req_builder.query(&[("console_server_ports", &s.to_string())]);
        }
        if let Some(ref s) = power_ports {
            req_builder = req_builder.query(&[("power_ports", &s.to_string())]);
        }
        if let Some(ref s) = power_outlets {
            req_builder = req_builder.query(&[("power_outlets", &s.to_string())]);
        }
        if let Some(ref s) = interfaces {
            req_builder = req_builder.query(&[("interfaces", &s.to_string())]);
        }
        if let Some(ref s) = pass_through_ports {
            req_builder = req_builder.query(&[("pass_through_ports", &s.to_string())]);
        }
        if let Some(ref s) = device_bays {
            req_builder = req_builder.query(&[("device_bays", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_types_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-types/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_types_read(&self, id: i32) -> Result<crate::models::DeviceType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-types/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_device_types_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceType,
    ) -> Result<crate::models::DeviceType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/device-types/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_create(
        &self,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_devices_graphs(
        &self,
        id: i32,
    ) -> Result<crate::models::DeviceWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/devices/{id}/graphs/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        asset_tag: Option<&str>,
        face: Option<&str>,
        position: Option<&str>,
        vc_position: Option<&str>,
        vc_priority: Option<&str>,
        local_context_data: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        device_type_id: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        platform_id: Option<&str>,
        platform: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        rack_group_id: Option<&str>,
        rack_id: Option<&str>,
        cluster_id: Option<&str>,
        model: Option<&str>,
        status: Option<&str>,
        is_full_depth: Option<&str>,
        mac_address: Option<&str>,
        serial: Option<&str>,
        has_primary_ip: Option<&str>,
        virtual_chassis_id: Option<&str>,
        virtual_chassis_member: Option<&str>,
        console_ports: Option<&str>,
        console_server_ports: Option<&str>,
        power_ports: Option<&str>,
        power_outlets: Option<&str>,
        interfaces: Option<&str>,
        pass_through_ports: Option<&str>,
        device_bays: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20013, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = asset_tag {
            req_builder = req_builder.query(&[("asset_tag", &s.to_string())]);
        }
        if let Some(ref s) = face {
            req_builder = req_builder.query(&[("face", &s.to_string())]);
        }
        if let Some(ref s) = position {
            req_builder = req_builder.query(&[("position", &s.to_string())]);
        }
        if let Some(ref s) = vc_position {
            req_builder = req_builder.query(&[("vc_position", &s.to_string())]);
        }
        if let Some(ref s) = vc_priority {
            req_builder = req_builder.query(&[("vc_priority", &s.to_string())]);
        }
        if let Some(ref s) = local_context_data {
            req_builder = req_builder.query(&[("local_context_data", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer_id {
            req_builder = req_builder.query(&[("manufacturer_id", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer {
            req_builder = req_builder.query(&[("manufacturer", &s.to_string())]);
        }
        if let Some(ref s) = device_type_id {
            req_builder = req_builder.query(&[("device_type_id", &s.to_string())]);
        }
        if let Some(ref s) = role_id {
            req_builder = req_builder.query(&[("role_id", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = platform_id {
            req_builder = req_builder.query(&[("platform_id", &s.to_string())]);
        }
        if let Some(ref s) = platform {
            req_builder = req_builder.query(&[("platform", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = rack_group_id {
            req_builder = req_builder.query(&[("rack_group_id", &s.to_string())]);
        }
        if let Some(ref s) = rack_id {
            req_builder = req_builder.query(&[("rack_id", &s.to_string())]);
        }
        if let Some(ref s) = cluster_id {
            req_builder = req_builder.query(&[("cluster_id", &s.to_string())]);
        }
        if let Some(ref s) = model {
            req_builder = req_builder.query(&[("model", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = is_full_depth {
            req_builder = req_builder.query(&[("is_full_depth", &s.to_string())]);
        }
        if let Some(ref s) = mac_address {
            req_builder = req_builder.query(&[("mac_address", &s.to_string())]);
        }
        if let Some(ref s) = serial {
            req_builder = req_builder.query(&[("serial", &s.to_string())]);
        }
        if let Some(ref s) = has_primary_ip {
            req_builder = req_builder.query(&[("has_primary_ip", &s.to_string())]);
        }
        if let Some(ref s) = virtual_chassis_id {
            req_builder = req_builder.query(&[("virtual_chassis_id", &s.to_string())]);
        }
        if let Some(ref s) = virtual_chassis_member {
            req_builder = req_builder.query(&[("virtual_chassis_member", &s.to_string())]);
        }
        if let Some(ref s) = console_ports {
            req_builder = req_builder.query(&[("console_ports", &s.to_string())]);
        }
        if let Some(ref s) = console_server_ports {
            req_builder = req_builder.query(&[("console_server_ports", &s.to_string())]);
        }
        if let Some(ref s) = power_ports {
            req_builder = req_builder.query(&[("power_ports", &s.to_string())]);
        }
        if let Some(ref s) = power_outlets {
            req_builder = req_builder.query(&[("power_outlets", &s.to_string())]);
        }
        if let Some(ref s) = interfaces {
            req_builder = req_builder.query(&[("interfaces", &s.to_string())]);
        }
        if let Some(ref s) = pass_through_ports {
            req_builder = req_builder.query(&[("pass_through_ports", &s.to_string())]);
        }
        if let Some(ref s) = device_bays {
            req_builder = req_builder.query(&[("device_bays", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_napalm(
        &self,
        id: i32,
        method: &str,
    ) -> Result<crate::models::DeviceNapalm, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/devices/{id}/napalm/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("method", &method.to_string())]);
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_read(&self, id: i32) -> Result<crate::models::DeviceWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_devices_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceWithConfigContext,
    ) -> Result<crate::models::DeviceWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/devices/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_port_templates_create(
        &self,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/front-port-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_port_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_front_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20014, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/front-port-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::FrontPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPortTemplate,
    ) -> Result<crate::models::FrontPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_ports_create(
        &self,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/front-ports/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_ports_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_front_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20015, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/front-ports/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_ports_read(&self, id: i32) -> Result<crate::models::FrontPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_front_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableFrontPort,
    ) -> Result<crate::models::FrontPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/front-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_connections_list(
        &self,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20016, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interface-connections/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_templates_create(
        &self,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interface-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interface-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_interface_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        mgmt_only: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20017, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interface-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = mgmt_only {
            req_builder = req_builder.query(&[("mgmt_only", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interface-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::InterfaceTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interface-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interface_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableInterfaceTemplate,
    ) -> Result<crate::models::InterfaceTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interface-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_create(
        &self,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_interfaces_graphs(&self, id: i32) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interfaces/{id}/graphs/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        connection_status: Option<&str>,
        _type: Option<&str>,
        enabled: Option<&str>,
        mtu: Option<&str>,
        mgmt_only: Option<&str>,
        mode: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        kind: Option<&str>,
        lag_id: Option<&str>,
        mac_address: Option<&str>,
        vlan_id: Option<&str>,
        vlan: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20018, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = enabled {
            req_builder = req_builder.query(&[("enabled", &s.to_string())]);
        }
        if let Some(ref s) = mtu {
            req_builder = req_builder.query(&[("mtu", &s.to_string())]);
        }
        if let Some(ref s) = mgmt_only {
            req_builder = req_builder.query(&[("mgmt_only", &s.to_string())]);
        }
        if let Some(ref s) = mode {
            req_builder = req_builder.query(&[("mode", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = kind {
            req_builder = req_builder.query(&[("kind", &s.to_string())]);
        }
        if let Some(ref s) = lag_id {
            req_builder = req_builder.query(&[("lag_id", &s.to_string())]);
        }
        if let Some(ref s) = mac_address {
            req_builder = req_builder.query(&[("mac_address", &s.to_string())]);
        }
        if let Some(ref s) = vlan_id {
            req_builder = req_builder.query(&[("vlan_id", &s.to_string())]);
        }
        if let Some(ref s) = vlan {
            req_builder = req_builder.query(&[("vlan", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_read(&self, id: i32) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_trace(&self, id: i32) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/interfaces/{id}/trace/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_interfaces_update(
        &self,
        id: i32,
        data: crate::models::WritableDeviceInterface,
    ) -> Result<crate::models::DeviceInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/interfaces/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_inventory_items_create(
        &self,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/inventory-items/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_inventory_items_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/inventory-items/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_inventory_items_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        part_id: Option<&str>,
        asset_tag: Option<&str>,
        discovered: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        parent_id: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        serial: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20019, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/inventory-items/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = part_id {
            req_builder = req_builder.query(&[("part_id", &s.to_string())]);
        }
        if let Some(ref s) = asset_tag {
            req_builder = req_builder.query(&[("asset_tag", &s.to_string())]);
        }
        if let Some(ref s) = discovered {
            req_builder = req_builder.query(&[("discovered", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = parent_id {
            req_builder = req_builder.query(&[("parent_id", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer_id {
            req_builder = req_builder.query(&[("manufacturer_id", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer {
            req_builder = req_builder.query(&[("manufacturer", &s.to_string())]);
        }
        if let Some(ref s) = serial {
            req_builder = req_builder.query(&[("serial", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_inventory_items_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/inventory-items/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_inventory_items_read(&self, id: i32) -> Result<crate::models::InventoryItem, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/inventory-items/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_inventory_items_update(
        &self,
        id: i32,
        data: crate::models::WritableInventoryItem,
    ) -> Result<crate::models::InventoryItem, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/inventory-items/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_manufacturers_create(
        &self,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/manufacturers/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_manufacturers_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/manufacturers/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_manufacturers_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20020, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/manufacturers/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_manufacturers_partial_update(
        &self,
        id: i32,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/manufacturers/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_manufacturers_read(&self, id: i32) -> Result<crate::models::Manufacturer, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/manufacturers/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_manufacturers_update(
        &self,
        id: i32,
        data: crate::models::Manufacturer,
    ) -> Result<crate::models::Manufacturer, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/manufacturers/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_platforms_create(
        &self,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_platforms_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_platforms_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        napalm_driver: Option<&str>,
        q: Option<&str>,
        manufacturer_id: Option<&str>,
        manufacturer: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20021, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = napalm_driver {
            req_builder = req_builder.query(&[("napalm_driver", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer_id {
            req_builder = req_builder.query(&[("manufacturer_id", &s.to_string())]);
        }
        if let Some(ref s) = manufacturer {
            req_builder = req_builder.query(&[("manufacturer", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_platforms_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_platforms_read(&self, id: i32) -> Result<crate::models::Platform, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_platforms_update(
        &self,
        id: i32,
        data: crate::models::WritablePlatform,
    ) -> Result<crate::models::Platform, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/platforms/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_connections_list(
        &self,
        name: Option<&str>,
        connection_status: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20022, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-connections/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_feeds_create(
        &self,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-feeds/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_feeds_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-feeds/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_feeds_list(
        &self,
        name: Option<&str>,
        status: Option<&str>,
        _type: Option<&str>,
        supply: Option<&str>,
        phase: Option<&str>,
        voltage: Option<&str>,
        amperage: Option<&str>,
        max_utilization: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        power_panel_id: Option<&str>,
        rack_id: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20023, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-feeds/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = supply {
            req_builder = req_builder.query(&[("supply", &s.to_string())]);
        }
        if let Some(ref s) = phase {
            req_builder = req_builder.query(&[("phase", &s.to_string())]);
        }
        if let Some(ref s) = voltage {
            req_builder = req_builder.query(&[("voltage", &s.to_string())]);
        }
        if let Some(ref s) = amperage {
            req_builder = req_builder.query(&[("amperage", &s.to_string())]);
        }
        if let Some(ref s) = max_utilization {
            req_builder = req_builder.query(&[("max_utilization", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = power_panel_id {
            req_builder = req_builder.query(&[("power_panel_id", &s.to_string())]);
        }
        if let Some(ref s) = rack_id {
            req_builder = req_builder.query(&[("rack_id", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_feeds_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-feeds/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_feeds_read(&self, id: i32) -> Result<crate::models::PowerFeed, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-feeds/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_feeds_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerFeed,
    ) -> Result<crate::models::PowerFeed, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-feeds/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlet_templates_create(
        &self,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-outlet-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlet_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlet-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_outlet_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        feed_leg: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20024, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-outlet-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = feed_leg {
            req_builder = req_builder.query(&[("feed_leg", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlet_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlet-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlet_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::PowerOutletTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlet-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlet_templates_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutletTemplate,
    ) -> Result<crate::models::PowerOutletTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlet-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_create(
        &self,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-outlets/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlets/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_outlets_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        feed_leg: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20025, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-outlets/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = feed_leg {
            req_builder = req_builder.query(&[("feed_leg", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlets/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_read(&self, id: i32) -> Result<crate::models::PowerOutlet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlets/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_trace(&self, id: i32) -> Result<crate::models::PowerOutlet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlets/{id}/trace/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_outlets_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerOutlet,
    ) -> Result<crate::models::PowerOutlet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-outlets/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_panels_create(
        &self,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-panels/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_panels_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-panels/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_panels_list(
        &self,
        name: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        rack_group_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20026, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-panels/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = rack_group_id {
            req_builder = req_builder.query(&[("rack_group_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_panels_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-panels/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_panels_read(&self, id: i32) -> Result<crate::models::PowerPanel, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-panels/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_panels_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPanel,
    ) -> Result<crate::models::PowerPanel, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-panels/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_port_templates_create(
        &self,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-port-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_port_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        maximum_draw: Option<&str>,
        allocated_draw: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20027, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-port-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = maximum_draw {
            req_builder = req_builder.query(&[("maximum_draw", &s.to_string())]);
        }
        if let Some(ref s) = allocated_draw {
            req_builder = req_builder.query(&[("allocated_draw", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::PowerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPortTemplate,
    ) -> Result<crate::models::PowerPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_create(
        &self,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-ports/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_power_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        maximum_draw: Option<&str>,
        allocated_draw: Option<&str>,
        description: Option<&str>,
        connection_status: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        _type: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20022, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/power-ports/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = maximum_draw {
            req_builder = req_builder.query(&[("maximum_draw", &s.to_string())]);
        }
        if let Some(ref s) = allocated_draw {
            req_builder = req_builder.query(&[("allocated_draw", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = connection_status {
            req_builder = req_builder.query(&[("connection_status", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_read(&self, id: i32) -> Result<crate::models::PowerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_trace(&self, id: i32) -> Result<crate::models::PowerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-ports/{id}/trace/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_power_ports_update(
        &self,
        id: i32,
        data: crate::models::WritablePowerPort,
    ) -> Result<crate::models::PowerPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/power-ports/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_groups_create(
        &self,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-groups/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_groups_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_rack_groups_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20028, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-groups/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_groups_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_groups_read(&self, id: i32) -> Result<crate::models::RackGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_groups_update(
        &self,
        id: i32,
        data: crate::models::WritableRackGroup,
    ) -> Result<crate::models::RackGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_reservations_create(
        &self,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-reservations/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_reservations_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-reservations/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_rack_reservations_list(
        &self,
        created: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        rack_id: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        user_id: Option<&str>,
        user: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20029, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-reservations/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = rack_id {
            req_builder = req_builder.query(&[("rack_id", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = group_id {
            req_builder = req_builder.query(&[("group_id", &s.to_string())]);
        }
        if let Some(ref s) = group {
            req_builder = req_builder.query(&[("group", &s.to_string())]);
        }
        if let Some(ref s) = user_id {
            req_builder = req_builder.query(&[("user_id", &s.to_string())]);
        }
        if let Some(ref s) = user {
            req_builder = req_builder.query(&[("user", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_reservations_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-reservations/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_reservations_read(
        &self,
        id: i32,
    ) -> Result<crate::models::RackReservation, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-reservations/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_reservations_update(
        &self,
        id: i32,
        data: crate::models::WritableRackReservation,
    ) -> Result<crate::models::RackReservation, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rack-reservations/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_roles_create(
        &self,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_roles_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_rack_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        color: Option<&str>,
        q: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20030, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = color {
            req_builder = req_builder.query(&[("color", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_roles_read(&self, id: i32) -> Result<crate::models::RackRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rack_roles_update(
        &self,
        id: i32,
        data: crate::models::RackRole,
    ) -> Result<crate::models::RackRole, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rack-roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_create(
        &self,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_racks_elevation(
        &self,
        id: i32,
        q: Option<&str>,
        face: Option<&str>,
        render: Option<&str>,
        unit_width: Option<i32>,
        unit_height: Option<i32>,
        legend_width: Option<i32>,
        exclude: Option<i32>,
        expand_devices: Option<bool>,
        include_images: Option<bool>,
    ) -> Result<Vec<crate::models::RackUnit>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/racks/{id}/elevation/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = face {
            req_builder = req_builder.query(&[("face", &s.to_string())]);
        }
        if let Some(ref s) = render {
            req_builder = req_builder.query(&[("render", &s.to_string())]);
        }
        if let Some(ref s) = unit_width {
            req_builder = req_builder.query(&[("unit_width", &s.to_string())]);
        }
        if let Some(ref s) = unit_height {
            req_builder = req_builder.query(&[("unit_height", &s.to_string())]);
        }
        if let Some(ref s) = legend_width {
            req_builder = req_builder.query(&[("legend_width", &s.to_string())]);
        }
        if let Some(ref s) = exclude {
            req_builder = req_builder.query(&[("exclude", &s.to_string())]);
        }
        if let Some(ref s) = expand_devices {
            req_builder = req_builder.query(&[("expand_devices", &s.to_string())]);
        }
        if let Some(ref s) = include_images {
            req_builder = req_builder.query(&[("include_images", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        facility_id: Option<&str>,
        asset_tag: Option<&str>,
        _type: Option<&str>,
        width: Option<&str>,
        u_height: Option<&str>,
        desc_units: Option<&str>,
        outer_width: Option<&str>,
        outer_depth: Option<&str>,
        outer_unit: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        status: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        serial: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20031, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = facility_id {
            req_builder = req_builder.query(&[("facility_id", &s.to_string())]);
        }
        if let Some(ref s) = asset_tag {
            req_builder = req_builder.query(&[("asset_tag", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = width {
            req_builder = req_builder.query(&[("width", &s.to_string())]);
        }
        if let Some(ref s) = u_height {
            req_builder = req_builder.query(&[("u_height", &s.to_string())]);
        }
        if let Some(ref s) = desc_units {
            req_builder = req_builder.query(&[("desc_units", &s.to_string())]);
        }
        if let Some(ref s) = outer_width {
            req_builder = req_builder.query(&[("outer_width", &s.to_string())]);
        }
        if let Some(ref s) = outer_depth {
            req_builder = req_builder.query(&[("outer_depth", &s.to_string())]);
        }
        if let Some(ref s) = outer_unit {
            req_builder = req_builder.query(&[("outer_unit", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = group_id {
            req_builder = req_builder.query(&[("group_id", &s.to_string())]);
        }
        if let Some(ref s) = group {
            req_builder = req_builder.query(&[("group", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = role_id {
            req_builder = req_builder.query(&[("role_id", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = serial {
            req_builder = req_builder.query(&[("serial", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_read(&self, id: i32) -> Result<crate::models::Rack, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_units(&self, id: i32) -> Result<crate::models::Rack, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/racks/{id}/units/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_racks_update(
        &self,
        id: i32,
        data: crate::models::WritableRack,
    ) -> Result<crate::models::Rack, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/racks/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_port_templates_create(
        &self,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-port-templates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_port_templates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rear-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_rear_port_templates_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        positions: Option<&str>,
        q: Option<&str>,
        devicetype_id: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20032, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-port-templates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = positions {
            req_builder = req_builder.query(&[("positions", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = devicetype_id {
            req_builder = req_builder.query(&[("devicetype_id", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_port_templates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rear-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_port_templates_read(
        &self,
        id: i32,
    ) -> Result<crate::models::RearPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rear-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_port_templates_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPortTemplate,
    ) -> Result<crate::models::RearPortTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/rear-port-templates/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_ports_create(
        &self,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_ports_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_rear_ports_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        _type: Option<&str>,
        positions: Option<&str>,
        description: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        tag: Option<&str>,
        cabled: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20033, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = positions {
            req_builder = req_builder.query(&[("positions", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = cabled {
            req_builder = req_builder.query(&[("cabled", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_ports_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_ports_read(&self, id: i32) -> Result<crate::models::RearPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_rear_ports_update(
        &self,
        id: i32,
        data: crate::models::WritableRearPort,
    ) -> Result<crate::models::RearPort, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/rear-ports/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_regions_create(
        &self,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_regions_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_regions_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        parent_id: Option<&str>,
        parent: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20034, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = parent_id {
            req_builder = req_builder.query(&[("parent_id", &s.to_string())]);
        }
        if let Some(ref s) = parent {
            req_builder = req_builder.query(&[("parent", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_regions_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_regions_read(&self, id: i32) -> Result<crate::models::Region, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_regions_update(
        &self,
        id: i32,
        data: crate::models::WritableRegion,
    ) -> Result<crate::models::Region, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/regions/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_create(
        &self,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_sites_graphs(&self, id: i32) -> Result<crate::models::Site, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/sites/{id}/graphs/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        facility: Option<&str>,
        asn: Option<&str>,
        latitude: Option<&str>,
        longitude: Option<&str>,
        contact_name: Option<&str>,
        contact_phone: Option<&str>,
        contact_email: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        status: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20035, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = facility {
            req_builder = req_builder.query(&[("facility", &s.to_string())]);
        }
        if let Some(ref s) = asn {
            req_builder = req_builder.query(&[("asn", &s.to_string())]);
        }
        if let Some(ref s) = latitude {
            req_builder = req_builder.query(&[("latitude", &s.to_string())]);
        }
        if let Some(ref s) = longitude {
            req_builder = req_builder.query(&[("longitude", &s.to_string())]);
        }
        if let Some(ref s) = contact_name {
            req_builder = req_builder.query(&[("contact_name", &s.to_string())]);
        }
        if let Some(ref s) = contact_phone {
            req_builder = req_builder.query(&[("contact_phone", &s.to_string())]);
        }
        if let Some(ref s) = contact_email {
            req_builder = req_builder.query(&[("contact_email", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_read(&self, id: i32) -> Result<crate::models::Site, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_sites_update(
        &self,
        id: i32,
        data: crate::models::WritableSite,
    ) -> Result<crate::models::Site, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/sites/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_virtual_chassis_create(
        &self,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/virtual-chassis/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_virtual_chassis_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/virtual-chassis/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn dcim_virtual_chassis_list(
        &self,
        id: Option<&str>,
        domain: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        tag: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20036, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/dcim/virtual-chassis/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = domain {
            req_builder = req_builder.query(&[("domain", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_virtual_chassis_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/virtual-chassis/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_virtual_chassis_read(&self, id: i32) -> Result<crate::models::VirtualChassis, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/virtual-chassis/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn dcim_virtual_chassis_update(
        &self,
        id: i32,
        data: crate::models::WritableVirtualChassis,
    ) -> Result<crate::models::VirtualChassis, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/dcim/virtual-chassis/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }
}
