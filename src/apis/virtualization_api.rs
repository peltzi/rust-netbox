/*
 * NetBox API
 *
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.7
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use reqwest;

use super::{Error, configuration};

pub struct VirtualizationApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl VirtualizationApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> VirtualizationApiClient {
        VirtualizationApiClient {
            configuration,
        }
    }
}

pub trait VirtualizationApi {
    fn virtualization_choices_list(&self, ) -> Result<(), Error>;
    fn virtualization_choices_read(&self, id: &str) -> Result<(), Error>;
    fn virtualization_cluster_groups_create(&self, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error>;
    fn virtualization_cluster_groups_delete(&self, id: i32) -> Result<(), Error>;
    fn virtualization_cluster_groups_list(&self, id: Option<&str>, name: Option<&str>, slug: Option<&str>, q: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20056, Error>;
    fn virtualization_cluster_groups_partial_update(&self, id: i32, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error>;
    fn virtualization_cluster_groups_read(&self, id: i32) -> Result<crate::models::ClusterGroup, Error>;
    fn virtualization_cluster_groups_update(&self, id: i32, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error>;
    fn virtualization_cluster_types_create(&self, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error>;
    fn virtualization_cluster_types_delete(&self, id: i32) -> Result<(), Error>;
    fn virtualization_cluster_types_list(&self, id: Option<&str>, name: Option<&str>, slug: Option<&str>, q: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20057, Error>;
    fn virtualization_cluster_types_partial_update(&self, id: i32, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error>;
    fn virtualization_cluster_types_read(&self, id: i32) -> Result<crate::models::ClusterType, Error>;
    fn virtualization_cluster_types_update(&self, id: i32, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error>;
    fn virtualization_clusters_create(&self, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error>;
    fn virtualization_clusters_delete(&self, id: i32) -> Result<(), Error>;
    fn virtualization_clusters_list(&self, name: Option<&str>, created: Option<&str>, created__gte: Option<&str>, created__lte: Option<&str>, last_updated: Option<&str>, last_updated__gte: Option<&str>, last_updated__lte: Option<&str>, id__in: Option<&str>, q: Option<&str>, region_id: Option<&str>, region: Option<&str>, site_id: Option<&str>, site: Option<&str>, group_id: Option<&str>, group: Option<&str>, type_id: Option<&str>, _type: Option<&str>, tenant: Option<&str>, tag: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20058, Error>;
    fn virtualization_clusters_partial_update(&self, id: i32, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error>;
    fn virtualization_clusters_read(&self, id: i32) -> Result<crate::models::Cluster, Error>;
    fn virtualization_clusters_update(&self, id: i32, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error>;
    fn virtualization_interfaces_create(&self, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error>;
    fn virtualization_interfaces_delete(&self, id: i32) -> Result<(), Error>;
    fn virtualization_interfaces_list(&self, id: Option<&str>, name: Option<&str>, enabled: Option<&str>, mtu: Option<&str>, q: Option<&str>, virtual_machine_id: Option<&str>, virtual_machine: Option<&str>, mac_address: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20059, Error>;
    fn virtualization_interfaces_partial_update(&self, id: i32, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error>;
    fn virtualization_interfaces_read(&self, id: i32) -> Result<crate::models::VirtualMachineInterface, Error>;
    fn virtualization_interfaces_update(&self, id: i32, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error>;
    fn virtualization_virtual_machines_create(&self, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error>;
    fn virtualization_virtual_machines_delete(&self, id: i32) -> Result<(), Error>;
    fn virtualization_virtual_machines_list(&self, id: Option<&str>, name: Option<&str>, cluster: Option<&str>, vcpus: Option<&str>, memory: Option<&str>, disk: Option<&str>, local_context_data: Option<&str>, tenant_group_id: Option<&str>, tenant_group: Option<&str>, tenant_id: Option<&str>, tenant: Option<&str>, created: Option<&str>, created__gte: Option<&str>, created__lte: Option<&str>, last_updated: Option<&str>, last_updated__gte: Option<&str>, last_updated__lte: Option<&str>, id__in: Option<&str>, q: Option<&str>, status: Option<&str>, cluster_group_id: Option<&str>, cluster_group: Option<&str>, cluster_type_id: Option<&str>, cluster_type: Option<&str>, cluster_id: Option<&str>, region_id: Option<&str>, region: Option<&str>, site_id: Option<&str>, site: Option<&str>, role_id: Option<&str>, role: Option<&str>, platform_id: Option<&str>, platform: Option<&str>, mac_address: Option<&str>, tag: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20060, Error>;
    fn virtualization_virtual_machines_partial_update(&self, id: i32, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error>;
    fn virtualization_virtual_machines_read(&self, id: i32) -> Result<crate::models::VirtualMachineWithConfigContext, Error>;
    fn virtualization_virtual_machines_update(&self, id: i32, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error>;
}

impl VirtualizationApi for VirtualizationApiClient {
    fn virtualization_choices_list(&self, ) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/_choices/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_choices_read(&self, id: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/_choices/{id}/", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_cluster_groups_create(&self, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_groups_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_cluster_groups_list(&self, id: Option<&str>, name: Option<&str>, slug: Option<&str>, q: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20056, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_groups_partial_update(&self, id: i32, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_groups_read(&self, id: i32) -> Result<crate::models::ClusterGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_groups_update(&self, id: i32, data: crate::models::ClusterGroup) -> Result<crate::models::ClusterGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-groups/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_types_create(&self, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_types_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_cluster_types_list(&self, id: Option<&str>, name: Option<&str>, slug: Option<&str>, q: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20057, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_types_partial_update(&self, id: i32, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_types_read(&self, id: i32) -> Result<crate::models::ClusterType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_cluster_types_update(&self, id: i32, data: crate::models::ClusterType) -> Result<crate::models::ClusterType, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/cluster-types/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_clusters_create(&self, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_clusters_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_clusters_list(&self, name: Option<&str>, created: Option<&str>, created__gte: Option<&str>, created__lte: Option<&str>, last_updated: Option<&str>, last_updated__gte: Option<&str>, last_updated__lte: Option<&str>, id__in: Option<&str>, q: Option<&str>, region_id: Option<&str>, region: Option<&str>, site_id: Option<&str>, site: Option<&str>, group_id: Option<&str>, group: Option<&str>, type_id: Option<&str>, _type: Option<&str>, tenant: Option<&str>, tag: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20058, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = group_id {
            req_builder = req_builder.query(&[("group_id", &s.to_string())]);
        }
        if let Some(ref s) = group {
            req_builder = req_builder.query(&[("group", &s.to_string())]);
        }
        if let Some(ref s) = type_id {
            req_builder = req_builder.query(&[("type_id", &s.to_string())]);
        }
        if let Some(ref s) = _type {
            req_builder = req_builder.query(&[("type", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_clusters_partial_update(&self, id: i32, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_clusters_read(&self, id: i32) -> Result<crate::models::Cluster, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_clusters_update(&self, id: i32, data: crate::models::WritableCluster) -> Result<crate::models::Cluster, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/clusters/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_interfaces_create(&self, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_interfaces_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_interfaces_list(&self, id: Option<&str>, name: Option<&str>, enabled: Option<&str>, mtu: Option<&str>, q: Option<&str>, virtual_machine_id: Option<&str>, virtual_machine: Option<&str>, mac_address: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20059, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = enabled {
            req_builder = req_builder.query(&[("enabled", &s.to_string())]);
        }
        if let Some(ref s) = mtu {
            req_builder = req_builder.query(&[("mtu", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine_id {
            req_builder = req_builder.query(&[("virtual_machine_id", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine {
            req_builder = req_builder.query(&[("virtual_machine", &s.to_string())]);
        }
        if let Some(ref s) = mac_address {
            req_builder = req_builder.query(&[("mac_address", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_interfaces_partial_update(&self, id: i32, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_interfaces_read(&self, id: i32) -> Result<crate::models::VirtualMachineInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_interfaces_update(&self, id: i32, data: crate::models::WritableVirtualMachineInterface) -> Result<crate::models::VirtualMachineInterface, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/interfaces/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_virtual_machines_create(&self, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_virtual_machines_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn virtualization_virtual_machines_list(&self, id: Option<&str>, name: Option<&str>, cluster: Option<&str>, vcpus: Option<&str>, memory: Option<&str>, disk: Option<&str>, local_context_data: Option<&str>, tenant_group_id: Option<&str>, tenant_group: Option<&str>, tenant_id: Option<&str>, tenant: Option<&str>, created: Option<&str>, created__gte: Option<&str>, created__lte: Option<&str>, last_updated: Option<&str>, last_updated__gte: Option<&str>, last_updated__lte: Option<&str>, id__in: Option<&str>, q: Option<&str>, status: Option<&str>, cluster_group_id: Option<&str>, cluster_group: Option<&str>, cluster_type_id: Option<&str>, cluster_type: Option<&str>, cluster_id: Option<&str>, region_id: Option<&str>, region: Option<&str>, site_id: Option<&str>, site: Option<&str>, role_id: Option<&str>, role: Option<&str>, platform_id: Option<&str>, platform: Option<&str>, mac_address: Option<&str>, tag: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<crate::models::InlineResponse20060, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = cluster {
            req_builder = req_builder.query(&[("cluster", &s.to_string())]);
        }
        if let Some(ref s) = vcpus {
            req_builder = req_builder.query(&[("vcpus", &s.to_string())]);
        }
        if let Some(ref s) = memory {
            req_builder = req_builder.query(&[("memory", &s.to_string())]);
        }
        if let Some(ref s) = disk {
            req_builder = req_builder.query(&[("disk", &s.to_string())]);
        }
        if let Some(ref s) = local_context_data {
            req_builder = req_builder.query(&[("local_context_data", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = cluster_group_id {
            req_builder = req_builder.query(&[("cluster_group_id", &s.to_string())]);
        }
        if let Some(ref s) = cluster_group {
            req_builder = req_builder.query(&[("cluster_group", &s.to_string())]);
        }
        if let Some(ref s) = cluster_type_id {
            req_builder = req_builder.query(&[("cluster_type_id", &s.to_string())]);
        }
        if let Some(ref s) = cluster_type {
            req_builder = req_builder.query(&[("cluster_type", &s.to_string())]);
        }
        if let Some(ref s) = cluster_id {
            req_builder = req_builder.query(&[("cluster_id", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = role_id {
            req_builder = req_builder.query(&[("role_id", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = platform_id {
            req_builder = req_builder.query(&[("platform_id", &s.to_string())]);
        }
        if let Some(ref s) = platform {
            req_builder = req_builder.query(&[("platform", &s.to_string())]);
        }
        if let Some(ref s) = mac_address {
            req_builder = req_builder.query(&[("mac_address", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_virtual_machines_partial_update(&self, id: i32, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_virtual_machines_read(&self, id: i32) -> Result<crate::models::VirtualMachineWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn virtualization_virtual_machines_update(&self, id: i32, data: crate::models::WritableVirtualMachineWithConfigContext) -> Result<crate::models::VirtualMachineWithConfigContext, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/virtualization/virtual-machines/{id}/", configuration.base_path, id=id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

}
