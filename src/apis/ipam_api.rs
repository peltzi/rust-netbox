/*
 * NetBox API
 *
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.7
 *
 * Generated by: https://openapi-generator.tech
 */

use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;
use std::rc::Rc;

use reqwest;

use super::{configuration, Error};

pub struct IpamApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl IpamApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> IpamApiClient {
        IpamApiClient { configuration }
    }
}

pub trait IpamApi {
    fn ipam_aggregates_create(
        &self,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error>;
    fn ipam_aggregates_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_aggregates_list(
        &self,
        family: Option<&str>,
        date_added: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        prefix: Option<&str>,
        rir_id: Option<&str>,
        rir: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        date_added__n: Option<&str>,
        date_added__lte: Option<&str>,
        date_added__lt: Option<&str>,
        date_added__gte: Option<&str>,
        date_added__gt: Option<&str>,
        rir_id__n: Option<&str>,
        rir__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20043, Error>;
    fn ipam_aggregates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error>;
    fn ipam_aggregates_read(&self, id: i32) -> Result<crate::models::Aggregate, Error>;
    fn ipam_aggregates_update(
        &self,
        id: i32,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error>;
    fn ipam_choices_list(&self) -> Result<(), Error>;
    fn ipam_choices_read(&self, id: &str) -> Result<(), Error>;
    fn ipam_ip_addresses_create(
        &self,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error>;
    fn ipam_ip_addresses_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_ip_addresses_list(
        &self,
        family: Option<&str>,
        dns_name: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        parent: Option<&str>,
        address: Option<&str>,
        mask_length: Option<f32>,
        vrf_id: Option<&str>,
        vrf: Option<&str>,
        device: Option<&str>,
        device_id: Option<&str>,
        virtual_machine_id: Option<&str>,
        virtual_machine: Option<&str>,
        interface: Option<&str>,
        interface_id: Option<&str>,
        assigned_to_interface: Option<&str>,
        status: Option<&str>,
        role: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        dns_name__n: Option<&str>,
        dns_name__ic: Option<&str>,
        dns_name__nic: Option<&str>,
        dns_name__iew: Option<&str>,
        dns_name__niew: Option<&str>,
        dns_name__isw: Option<&str>,
        dns_name__nisw: Option<&str>,
        dns_name__ie: Option<&str>,
        dns_name__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        vrf_id__n: Option<&str>,
        vrf__n: Option<&str>,
        virtual_machine_id__n: Option<&str>,
        virtual_machine__n: Option<&str>,
        interface__n: Option<&str>,
        interface_id__n: Option<&str>,
        status__n: Option<&str>,
        role__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20044, Error>;
    fn ipam_ip_addresses_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error>;
    fn ipam_ip_addresses_read(&self, id: i32) -> Result<crate::models::IpAddress, Error>;
    fn ipam_ip_addresses_update(
        &self,
        id: i32,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error>;
    fn ipam_prefixes_available_ips_create(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_available_ips_read(&self, id: i32) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_available_prefixes_create(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_available_prefixes_read(
        &self,
        id: i32,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_create(
        &self,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_prefixes_list(
        &self,
        family: Option<&str>,
        is_pool: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        prefix: Option<&str>,
        within: Option<&str>,
        within_include: Option<&str>,
        contains: Option<&str>,
        mask_length: Option<f32>,
        vrf_id: Option<&str>,
        vrf: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        vlan_id: Option<&str>,
        vlan_vid: Option<f32>,
        role_id: Option<&str>,
        role: Option<&str>,
        status: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        vrf_id__n: Option<&str>,
        vrf__n: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        vlan_id__n: Option<&str>,
        role_id__n: Option<&str>,
        role__n: Option<&str>,
        status__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20045, Error>;
    fn ipam_prefixes_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_read(&self, id: i32) -> Result<crate::models::Prefix, Error>;
    fn ipam_prefixes_update(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error>;
    fn ipam_rirs_create(&self, data: crate::models::Rir) -> Result<crate::models::Rir, Error>;
    fn ipam_rirs_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_rirs_list(
        &self,
        name: Option<&str>,
        slug: Option<&str>,
        is_private: Option<&str>,
        q: Option<&str>,
        id__in: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20046, Error>;
    fn ipam_rirs_partial_update(
        &self,
        id: i32,
        data: crate::models::Rir,
    ) -> Result<crate::models::Rir, Error>;
    fn ipam_rirs_read(&self, id: i32) -> Result<crate::models::Rir, Error>;
    fn ipam_rirs_update(
        &self,
        id: i32,
        data: crate::models::Rir,
    ) -> Result<crate::models::Rir, Error>;
    fn ipam_roles_create(&self, data: crate::models::Role) -> Result<crate::models::Role, Error>;
    fn ipam_roles_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20047, Error>;
    fn ipam_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::Role,
    ) -> Result<crate::models::Role, Error>;
    fn ipam_roles_read(&self, id: i32) -> Result<crate::models::Role, Error>;
    fn ipam_roles_update(
        &self,
        id: i32,
        data: crate::models::Role,
    ) -> Result<crate::models::Role, Error>;
    fn ipam_services_create(
        &self,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error>;
    fn ipam_services_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_services_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        protocol: Option<&str>,
        port: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        q: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        virtual_machine_id: Option<&str>,
        virtual_machine: Option<&str>,
        tag: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        protocol__n: Option<&str>,
        port__n: Option<&str>,
        port__lte: Option<&str>,
        port__lt: Option<&str>,
        port__gte: Option<&str>,
        port__gt: Option<&str>,
        device_id__n: Option<&str>,
        device__n: Option<&str>,
        virtual_machine_id__n: Option<&str>,
        virtual_machine__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20048, Error>;
    fn ipam_services_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error>;
    fn ipam_services_read(&self, id: i32) -> Result<crate::models::Service, Error>;
    fn ipam_services_update(
        &self,
        id: i32,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error>;
    fn ipam_vlan_groups_create(
        &self,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error>;
    fn ipam_vlan_groups_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_vlan_groups_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20049, Error>;
    fn ipam_vlan_groups_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error>;
    fn ipam_vlan_groups_read(&self, id: i32) -> Result<crate::models::VlanGroup, Error>;
    fn ipam_vlan_groups_update(
        &self,
        id: i32,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error>;
    fn ipam_vlans_create(
        &self,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error>;
    fn ipam_vlans_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_vlans_list(
        &self,
        vid: Option<&str>,
        name: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        status: Option<&str>,
        tag: Option<&str>,
        vid__n: Option<&str>,
        vid__lte: Option<&str>,
        vid__lt: Option<&str>,
        vid__gte: Option<&str>,
        vid__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        group_id__n: Option<&str>,
        group__n: Option<&str>,
        role_id__n: Option<&str>,
        role__n: Option<&str>,
        status__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20050, Error>;
    fn ipam_vlans_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error>;
    fn ipam_vlans_read(&self, id: i32) -> Result<crate::models::Vlan, Error>;
    fn ipam_vlans_update(
        &self,
        id: i32,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error>;
    fn ipam_vrfs_create(
        &self,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error>;
    fn ipam_vrfs_delete(&self, id: i32) -> Result<(), Error>;
    fn ipam_vrfs_list(
        &self,
        name: Option<&str>,
        rd: Option<&str>,
        enforce_unique: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        tag: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        rd__n: Option<&str>,
        rd__ic: Option<&str>,
        rd__nic: Option<&str>,
        rd__iew: Option<&str>,
        rd__niew: Option<&str>,
        rd__isw: Option<&str>,
        rd__nisw: Option<&str>,
        rd__ie: Option<&str>,
        rd__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20051, Error>;
    fn ipam_vrfs_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error>;
    fn ipam_vrfs_read(&self, id: i32) -> Result<crate::models::Vrf, Error>;
    fn ipam_vrfs_update(
        &self,
        id: i32,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error>;
}

impl IpamApi for IpamApiClient {
    fn ipam_aggregates_create(
        &self,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_aggregates_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_aggregates_list(
        &self,
        family: Option<&str>,
        date_added: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        prefix: Option<&str>,
        rir_id: Option<&str>,
        rir: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        date_added__n: Option<&str>,
        date_added__lte: Option<&str>,
        date_added__lt: Option<&str>,
        date_added__gte: Option<&str>,
        date_added__gt: Option<&str>,
        rir_id__n: Option<&str>,
        rir__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20043, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = family {
            req_builder = req_builder.query(&[("family", &s.to_string())]);
        }
        if let Some(ref s) = date_added {
            req_builder = req_builder.query(&[("date_added", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = prefix {
            req_builder = req_builder.query(&[("prefix", &s.to_string())]);
        }
        if let Some(ref s) = rir_id {
            req_builder = req_builder.query(&[("rir_id", &s.to_string())]);
        }
        if let Some(ref s) = rir {
            req_builder = req_builder.query(&[("rir", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = family__n {
            req_builder = req_builder.query(&[("family__n", &s.to_string())]);
        }
        if let Some(ref s) = date_added__n {
            req_builder = req_builder.query(&[("date_added__n", &s.to_string())]);
        }
        if let Some(ref s) = date_added__lte {
            req_builder = req_builder.query(&[("date_added__lte", &s.to_string())]);
        }
        if let Some(ref s) = date_added__lt {
            req_builder = req_builder.query(&[("date_added__lt", &s.to_string())]);
        }
        if let Some(ref s) = date_added__gte {
            req_builder = req_builder.query(&[("date_added__gte", &s.to_string())]);
        }
        if let Some(ref s) = date_added__gt {
            req_builder = req_builder.query(&[("date_added__gt", &s.to_string())]);
        }
        if let Some(ref s) = rir_id__n {
            req_builder = req_builder.query(&[("rir_id__n", &s.to_string())]);
        }
        if let Some(ref s) = rir__n {
            req_builder = req_builder.query(&[("rir__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_aggregates_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_aggregates_read(&self, id: i32) -> Result<crate::models::Aggregate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_aggregates_update(
        &self,
        id: i32,
        data: crate::models::WritableAggregate,
    ) -> Result<crate::models::Aggregate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/aggregates/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_choices_list(&self) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/_choices/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_choices_read(&self, id: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/_choices/{id}/",
            configuration.base_path,
            id = crate::apis::urlencode(id)
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_ip_addresses_create(
        &self,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/ip-addresses/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_ip_addresses_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/ip-addresses/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_ip_addresses_list(
        &self,
        family: Option<&str>,
        dns_name: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        parent: Option<&str>,
        address: Option<&str>,
        mask_length: Option<f32>,
        vrf_id: Option<&str>,
        vrf: Option<&str>,
        device: Option<&str>,
        device_id: Option<&str>,
        virtual_machine_id: Option<&str>,
        virtual_machine: Option<&str>,
        interface: Option<&str>,
        interface_id: Option<&str>,
        assigned_to_interface: Option<&str>,
        status: Option<&str>,
        role: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        dns_name__n: Option<&str>,
        dns_name__ic: Option<&str>,
        dns_name__nic: Option<&str>,
        dns_name__iew: Option<&str>,
        dns_name__niew: Option<&str>,
        dns_name__isw: Option<&str>,
        dns_name__nisw: Option<&str>,
        dns_name__ie: Option<&str>,
        dns_name__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        vrf_id__n: Option<&str>,
        vrf__n: Option<&str>,
        virtual_machine_id__n: Option<&str>,
        virtual_machine__n: Option<&str>,
        interface__n: Option<&str>,
        interface_id__n: Option<&str>,
        status__n: Option<&str>,
        role__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20044, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/ip-addresses/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = family {
            req_builder = req_builder.query(&[("family", &s.to_string())]);
        }
        if let Some(ref s) = dns_name {
            req_builder = req_builder.query(&[("dns_name", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = parent {
            req_builder = req_builder.query(&[("parent", &s.to_string())]);
        }
        if let Some(ref s) = address {
            req_builder = req_builder.query(&[("address", &s.to_string())]);
        }
        if let Some(ref s) = mask_length {
            req_builder = req_builder.query(&[("mask_length", &s.to_string())]);
        }
        if let Some(ref s) = vrf_id {
            req_builder = req_builder.query(&[("vrf_id", &s.to_string())]);
        }
        if let Some(ref s) = vrf {
            req_builder = req_builder.query(&[("vrf", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine_id {
            req_builder = req_builder.query(&[("virtual_machine_id", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine {
            req_builder = req_builder.query(&[("virtual_machine", &s.to_string())]);
        }
        if let Some(ref s) = interface {
            req_builder = req_builder.query(&[("interface", &s.to_string())]);
        }
        if let Some(ref s) = interface_id {
            req_builder = req_builder.query(&[("interface_id", &s.to_string())]);
        }
        if let Some(ref s) = assigned_to_interface {
            req_builder = req_builder.query(&[("assigned_to_interface", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = family__n {
            req_builder = req_builder.query(&[("family__n", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__n {
            req_builder = req_builder.query(&[("dns_name__n", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__ic {
            req_builder = req_builder.query(&[("dns_name__ic", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__nic {
            req_builder = req_builder.query(&[("dns_name__nic", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__iew {
            req_builder = req_builder.query(&[("dns_name__iew", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__niew {
            req_builder = req_builder.query(&[("dns_name__niew", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__isw {
            req_builder = req_builder.query(&[("dns_name__isw", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__nisw {
            req_builder = req_builder.query(&[("dns_name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__ie {
            req_builder = req_builder.query(&[("dns_name__ie", &s.to_string())]);
        }
        if let Some(ref s) = dns_name__nie {
            req_builder = req_builder.query(&[("dns_name__nie", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id__n {
            req_builder = req_builder.query(&[("tenant_group_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group__n {
            req_builder = req_builder.query(&[("tenant_group__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id__n {
            req_builder = req_builder.query(&[("tenant_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant__n {
            req_builder = req_builder.query(&[("tenant__n", &s.to_string())]);
        }
        if let Some(ref s) = vrf_id__n {
            req_builder = req_builder.query(&[("vrf_id__n", &s.to_string())]);
        }
        if let Some(ref s) = vrf__n {
            req_builder = req_builder.query(&[("vrf__n", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine_id__n {
            req_builder = req_builder.query(&[("virtual_machine_id__n", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine__n {
            req_builder = req_builder.query(&[("virtual_machine__n", &s.to_string())]);
        }
        if let Some(ref s) = interface__n {
            req_builder = req_builder.query(&[("interface__n", &s.to_string())]);
        }
        if let Some(ref s) = interface_id__n {
            req_builder = req_builder.query(&[("interface_id__n", &s.to_string())]);
        }
        if let Some(ref s) = status__n {
            req_builder = req_builder.query(&[("status__n", &s.to_string())]);
        }
        if let Some(ref s) = role__n {
            req_builder = req_builder.query(&[("role__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_ip_addresses_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/ip-addresses/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_ip_addresses_read(&self, id: i32) -> Result<crate::models::IpAddress, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/ip-addresses/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_ip_addresses_update(
        &self,
        id: i32,
        data: crate::models::WritableIpAddress,
    ) -> Result<crate::models::IpAddress, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/ip-addresses/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_available_ips_create(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/prefixes/{id}/available-ips/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_available_ips_read(&self, id: i32) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/prefixes/{id}/available-ips/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_available_prefixes_create(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/prefixes/{id}/available-prefixes/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_available_prefixes_read(
        &self,
        id: i32,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/prefixes/{id}/available-prefixes/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_create(
        &self,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_prefixes_list(
        &self,
        family: Option<&str>,
        is_pool: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        prefix: Option<&str>,
        within: Option<&str>,
        within_include: Option<&str>,
        contains: Option<&str>,
        mask_length: Option<f32>,
        vrf_id: Option<&str>,
        vrf: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        vlan_id: Option<&str>,
        vlan_vid: Option<f32>,
        role_id: Option<&str>,
        role: Option<&str>,
        status: Option<&str>,
        tag: Option<&str>,
        family__n: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        vrf_id__n: Option<&str>,
        vrf__n: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        vlan_id__n: Option<&str>,
        role_id__n: Option<&str>,
        role__n: Option<&str>,
        status__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20045, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = family {
            req_builder = req_builder.query(&[("family", &s.to_string())]);
        }
        if let Some(ref s) = is_pool {
            req_builder = req_builder.query(&[("is_pool", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = prefix {
            req_builder = req_builder.query(&[("prefix", &s.to_string())]);
        }
        if let Some(ref s) = within {
            req_builder = req_builder.query(&[("within", &s.to_string())]);
        }
        if let Some(ref s) = within_include {
            req_builder = req_builder.query(&[("within_include", &s.to_string())]);
        }
        if let Some(ref s) = contains {
            req_builder = req_builder.query(&[("contains", &s.to_string())]);
        }
        if let Some(ref s) = mask_length {
            req_builder = req_builder.query(&[("mask_length", &s.to_string())]);
        }
        if let Some(ref s) = vrf_id {
            req_builder = req_builder.query(&[("vrf_id", &s.to_string())]);
        }
        if let Some(ref s) = vrf {
            req_builder = req_builder.query(&[("vrf", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = vlan_id {
            req_builder = req_builder.query(&[("vlan_id", &s.to_string())]);
        }
        if let Some(ref s) = vlan_vid {
            req_builder = req_builder.query(&[("vlan_vid", &s.to_string())]);
        }
        if let Some(ref s) = role_id {
            req_builder = req_builder.query(&[("role_id", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = family__n {
            req_builder = req_builder.query(&[("family__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id__n {
            req_builder = req_builder.query(&[("tenant_group_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group__n {
            req_builder = req_builder.query(&[("tenant_group__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id__n {
            req_builder = req_builder.query(&[("tenant_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant__n {
            req_builder = req_builder.query(&[("tenant__n", &s.to_string())]);
        }
        if let Some(ref s) = vrf_id__n {
            req_builder = req_builder.query(&[("vrf_id__n", &s.to_string())]);
        }
        if let Some(ref s) = vrf__n {
            req_builder = req_builder.query(&[("vrf__n", &s.to_string())]);
        }
        if let Some(ref s) = region_id__n {
            req_builder = req_builder.query(&[("region_id__n", &s.to_string())]);
        }
        if let Some(ref s) = region__n {
            req_builder = req_builder.query(&[("region__n", &s.to_string())]);
        }
        if let Some(ref s) = site_id__n {
            req_builder = req_builder.query(&[("site_id__n", &s.to_string())]);
        }
        if let Some(ref s) = site__n {
            req_builder = req_builder.query(&[("site__n", &s.to_string())]);
        }
        if let Some(ref s) = vlan_id__n {
            req_builder = req_builder.query(&[("vlan_id__n", &s.to_string())]);
        }
        if let Some(ref s) = role_id__n {
            req_builder = req_builder.query(&[("role_id__n", &s.to_string())]);
        }
        if let Some(ref s) = role__n {
            req_builder = req_builder.query(&[("role__n", &s.to_string())]);
        }
        if let Some(ref s) = status__n {
            req_builder = req_builder.query(&[("status__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_partial_update(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_read(&self, id: i32) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_prefixes_update(
        &self,
        id: i32,
        data: crate::models::WritablePrefix,
    ) -> Result<crate::models::Prefix, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/prefixes/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_rirs_create(&self, data: crate::models::Rir) -> Result<crate::models::Rir, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_rirs_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_rirs_list(
        &self,
        name: Option<&str>,
        slug: Option<&str>,
        is_private: Option<&str>,
        q: Option<&str>,
        id__in: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20046, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = is_private {
            req_builder = req_builder.query(&[("is_private", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = slug__n {
            req_builder = req_builder.query(&[("slug__n", &s.to_string())]);
        }
        if let Some(ref s) = slug__ic {
            req_builder = req_builder.query(&[("slug__ic", &s.to_string())]);
        }
        if let Some(ref s) = slug__nic {
            req_builder = req_builder.query(&[("slug__nic", &s.to_string())]);
        }
        if let Some(ref s) = slug__iew {
            req_builder = req_builder.query(&[("slug__iew", &s.to_string())]);
        }
        if let Some(ref s) = slug__niew {
            req_builder = req_builder.query(&[("slug__niew", &s.to_string())]);
        }
        if let Some(ref s) = slug__isw {
            req_builder = req_builder.query(&[("slug__isw", &s.to_string())]);
        }
        if let Some(ref s) = slug__nisw {
            req_builder = req_builder.query(&[("slug__nisw", &s.to_string())]);
        }
        if let Some(ref s) = slug__ie {
            req_builder = req_builder.query(&[("slug__ie", &s.to_string())]);
        }
        if let Some(ref s) = slug__nie {
            req_builder = req_builder.query(&[("slug__nie", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_rirs_partial_update(
        &self,
        id: i32,
        data: crate::models::Rir,
    ) -> Result<crate::models::Rir, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_rirs_read(&self, id: i32) -> Result<crate::models::Rir, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_rirs_update(
        &self,
        id: i32,
        data: crate::models::Rir,
    ) -> Result<crate::models::Rir, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/rirs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_roles_create(&self, data: crate::models::Role) -> Result<crate::models::Role, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_roles_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_roles_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20047, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = id__n {
            req_builder = req_builder.query(&[("id__n", &s.to_string())]);
        }
        if let Some(ref s) = id__lte {
            req_builder = req_builder.query(&[("id__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__lt {
            req_builder = req_builder.query(&[("id__lt", &s.to_string())]);
        }
        if let Some(ref s) = id__gte {
            req_builder = req_builder.query(&[("id__gte", &s.to_string())]);
        }
        if let Some(ref s) = id__gt {
            req_builder = req_builder.query(&[("id__gt", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = slug__n {
            req_builder = req_builder.query(&[("slug__n", &s.to_string())]);
        }
        if let Some(ref s) = slug__ic {
            req_builder = req_builder.query(&[("slug__ic", &s.to_string())]);
        }
        if let Some(ref s) = slug__nic {
            req_builder = req_builder.query(&[("slug__nic", &s.to_string())]);
        }
        if let Some(ref s) = slug__iew {
            req_builder = req_builder.query(&[("slug__iew", &s.to_string())]);
        }
        if let Some(ref s) = slug__niew {
            req_builder = req_builder.query(&[("slug__niew", &s.to_string())]);
        }
        if let Some(ref s) = slug__isw {
            req_builder = req_builder.query(&[("slug__isw", &s.to_string())]);
        }
        if let Some(ref s) = slug__nisw {
            req_builder = req_builder.query(&[("slug__nisw", &s.to_string())]);
        }
        if let Some(ref s) = slug__ie {
            req_builder = req_builder.query(&[("slug__ie", &s.to_string())]);
        }
        if let Some(ref s) = slug__nie {
            req_builder = req_builder.query(&[("slug__nie", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_roles_partial_update(
        &self,
        id: i32,
        data: crate::models::Role,
    ) -> Result<crate::models::Role, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_roles_read(&self, id: i32) -> Result<crate::models::Role, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_roles_update(
        &self,
        id: i32,
        data: crate::models::Role,
    ) -> Result<crate::models::Role, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/roles/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_services_create(
        &self,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_services_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_services_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        protocol: Option<&str>,
        port: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        q: Option<&str>,
        device_id: Option<&str>,
        device: Option<&str>,
        virtual_machine_id: Option<&str>,
        virtual_machine: Option<&str>,
        tag: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        protocol__n: Option<&str>,
        port__n: Option<&str>,
        port__lte: Option<&str>,
        port__lt: Option<&str>,
        port__gte: Option<&str>,
        port__gt: Option<&str>,
        device_id__n: Option<&str>,
        device__n: Option<&str>,
        virtual_machine_id__n: Option<&str>,
        virtual_machine__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20048, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = protocol {
            req_builder = req_builder.query(&[("protocol", &s.to_string())]);
        }
        if let Some(ref s) = port {
            req_builder = req_builder.query(&[("port", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = device_id {
            req_builder = req_builder.query(&[("device_id", &s.to_string())]);
        }
        if let Some(ref s) = device {
            req_builder = req_builder.query(&[("device", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine_id {
            req_builder = req_builder.query(&[("virtual_machine_id", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine {
            req_builder = req_builder.query(&[("virtual_machine", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = id__n {
            req_builder = req_builder.query(&[("id__n", &s.to_string())]);
        }
        if let Some(ref s) = id__lte {
            req_builder = req_builder.query(&[("id__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__lt {
            req_builder = req_builder.query(&[("id__lt", &s.to_string())]);
        }
        if let Some(ref s) = id__gte {
            req_builder = req_builder.query(&[("id__gte", &s.to_string())]);
        }
        if let Some(ref s) = id__gt {
            req_builder = req_builder.query(&[("id__gt", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = protocol__n {
            req_builder = req_builder.query(&[("protocol__n", &s.to_string())]);
        }
        if let Some(ref s) = port__n {
            req_builder = req_builder.query(&[("port__n", &s.to_string())]);
        }
        if let Some(ref s) = port__lte {
            req_builder = req_builder.query(&[("port__lte", &s.to_string())]);
        }
        if let Some(ref s) = port__lt {
            req_builder = req_builder.query(&[("port__lt", &s.to_string())]);
        }
        if let Some(ref s) = port__gte {
            req_builder = req_builder.query(&[("port__gte", &s.to_string())]);
        }
        if let Some(ref s) = port__gt {
            req_builder = req_builder.query(&[("port__gt", &s.to_string())]);
        }
        if let Some(ref s) = device_id__n {
            req_builder = req_builder.query(&[("device_id__n", &s.to_string())]);
        }
        if let Some(ref s) = device__n {
            req_builder = req_builder.query(&[("device__n", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine_id__n {
            req_builder = req_builder.query(&[("virtual_machine_id__n", &s.to_string())]);
        }
        if let Some(ref s) = virtual_machine__n {
            req_builder = req_builder.query(&[("virtual_machine__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_services_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_services_read(&self, id: i32) -> Result<crate::models::Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_services_update(
        &self,
        id: i32,
        data: crate::models::WritableService,
    ) -> Result<crate::models::Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/services/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlan_groups_create(
        &self,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlan-groups/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlan_groups_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/vlan-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_vlan_groups_list(
        &self,
        id: Option<&str>,
        name: Option<&str>,
        slug: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        id__n: Option<&str>,
        id__lte: Option<&str>,
        id__lt: Option<&str>,
        id__gte: Option<&str>,
        id__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        slug__n: Option<&str>,
        slug__ic: Option<&str>,
        slug__nic: Option<&str>,
        slug__iew: Option<&str>,
        slug__niew: Option<&str>,
        slug__isw: Option<&str>,
        slug__nisw: Option<&str>,
        slug__ie: Option<&str>,
        slug__nie: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20049, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlan-groups/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = id {
            req_builder = req_builder.query(&[("id", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = slug {
            req_builder = req_builder.query(&[("slug", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = id__n {
            req_builder = req_builder.query(&[("id__n", &s.to_string())]);
        }
        if let Some(ref s) = id__lte {
            req_builder = req_builder.query(&[("id__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__lt {
            req_builder = req_builder.query(&[("id__lt", &s.to_string())]);
        }
        if let Some(ref s) = id__gte {
            req_builder = req_builder.query(&[("id__gte", &s.to_string())]);
        }
        if let Some(ref s) = id__gt {
            req_builder = req_builder.query(&[("id__gt", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = slug__n {
            req_builder = req_builder.query(&[("slug__n", &s.to_string())]);
        }
        if let Some(ref s) = slug__ic {
            req_builder = req_builder.query(&[("slug__ic", &s.to_string())]);
        }
        if let Some(ref s) = slug__nic {
            req_builder = req_builder.query(&[("slug__nic", &s.to_string())]);
        }
        if let Some(ref s) = slug__iew {
            req_builder = req_builder.query(&[("slug__iew", &s.to_string())]);
        }
        if let Some(ref s) = slug__niew {
            req_builder = req_builder.query(&[("slug__niew", &s.to_string())]);
        }
        if let Some(ref s) = slug__isw {
            req_builder = req_builder.query(&[("slug__isw", &s.to_string())]);
        }
        if let Some(ref s) = slug__nisw {
            req_builder = req_builder.query(&[("slug__nisw", &s.to_string())]);
        }
        if let Some(ref s) = slug__ie {
            req_builder = req_builder.query(&[("slug__ie", &s.to_string())]);
        }
        if let Some(ref s) = slug__nie {
            req_builder = req_builder.query(&[("slug__nie", &s.to_string())]);
        }
        if let Some(ref s) = region_id__n {
            req_builder = req_builder.query(&[("region_id__n", &s.to_string())]);
        }
        if let Some(ref s) = region__n {
            req_builder = req_builder.query(&[("region__n", &s.to_string())]);
        }
        if let Some(ref s) = site_id__n {
            req_builder = req_builder.query(&[("site_id__n", &s.to_string())]);
        }
        if let Some(ref s) = site__n {
            req_builder = req_builder.query(&[("site__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlan_groups_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/vlan-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlan_groups_read(&self, id: i32) -> Result<crate::models::VlanGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/vlan-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlan_groups_update(
        &self,
        id: i32,
        data: crate::models::WritableVlanGroup,
    ) -> Result<crate::models::VlanGroup, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!(
            "{}/ipam/vlan-groups/{id}/",
            configuration.base_path,
            id = id
        );
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlans_create(
        &self,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlans_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_vlans_list(
        &self,
        vid: Option<&str>,
        name: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        region_id: Option<&str>,
        region: Option<&str>,
        site_id: Option<&str>,
        site: Option<&str>,
        group_id: Option<&str>,
        group: Option<&str>,
        role_id: Option<&str>,
        role: Option<&str>,
        status: Option<&str>,
        tag: Option<&str>,
        vid__n: Option<&str>,
        vid__lte: Option<&str>,
        vid__lt: Option<&str>,
        vid__gte: Option<&str>,
        vid__gt: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        region_id__n: Option<&str>,
        region__n: Option<&str>,
        site_id__n: Option<&str>,
        site__n: Option<&str>,
        group_id__n: Option<&str>,
        group__n: Option<&str>,
        role_id__n: Option<&str>,
        role__n: Option<&str>,
        status__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20050, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = vid {
            req_builder = req_builder.query(&[("vid", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = region_id {
            req_builder = req_builder.query(&[("region_id", &s.to_string())]);
        }
        if let Some(ref s) = region {
            req_builder = req_builder.query(&[("region", &s.to_string())]);
        }
        if let Some(ref s) = site_id {
            req_builder = req_builder.query(&[("site_id", &s.to_string())]);
        }
        if let Some(ref s) = site {
            req_builder = req_builder.query(&[("site", &s.to_string())]);
        }
        if let Some(ref s) = group_id {
            req_builder = req_builder.query(&[("group_id", &s.to_string())]);
        }
        if let Some(ref s) = group {
            req_builder = req_builder.query(&[("group", &s.to_string())]);
        }
        if let Some(ref s) = role_id {
            req_builder = req_builder.query(&[("role_id", &s.to_string())]);
        }
        if let Some(ref s) = role {
            req_builder = req_builder.query(&[("role", &s.to_string())]);
        }
        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = vid__n {
            req_builder = req_builder.query(&[("vid__n", &s.to_string())]);
        }
        if let Some(ref s) = vid__lte {
            req_builder = req_builder.query(&[("vid__lte", &s.to_string())]);
        }
        if let Some(ref s) = vid__lt {
            req_builder = req_builder.query(&[("vid__lt", &s.to_string())]);
        }
        if let Some(ref s) = vid__gte {
            req_builder = req_builder.query(&[("vid__gte", &s.to_string())]);
        }
        if let Some(ref s) = vid__gt {
            req_builder = req_builder.query(&[("vid__gt", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id__n {
            req_builder = req_builder.query(&[("tenant_group_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group__n {
            req_builder = req_builder.query(&[("tenant_group__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id__n {
            req_builder = req_builder.query(&[("tenant_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant__n {
            req_builder = req_builder.query(&[("tenant__n", &s.to_string())]);
        }
        if let Some(ref s) = region_id__n {
            req_builder = req_builder.query(&[("region_id__n", &s.to_string())]);
        }
        if let Some(ref s) = region__n {
            req_builder = req_builder.query(&[("region__n", &s.to_string())]);
        }
        if let Some(ref s) = site_id__n {
            req_builder = req_builder.query(&[("site_id__n", &s.to_string())]);
        }
        if let Some(ref s) = site__n {
            req_builder = req_builder.query(&[("site__n", &s.to_string())]);
        }
        if let Some(ref s) = group_id__n {
            req_builder = req_builder.query(&[("group_id__n", &s.to_string())]);
        }
        if let Some(ref s) = group__n {
            req_builder = req_builder.query(&[("group__n", &s.to_string())]);
        }
        if let Some(ref s) = role_id__n {
            req_builder = req_builder.query(&[("role_id__n", &s.to_string())]);
        }
        if let Some(ref s) = role__n {
            req_builder = req_builder.query(&[("role__n", &s.to_string())]);
        }
        if let Some(ref s) = status__n {
            req_builder = req_builder.query(&[("status__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlans_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlans_read(&self, id: i32) -> Result<crate::models::Vlan, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vlans_update(
        &self,
        id: i32,
        data: crate::models::WritableVlan,
    ) -> Result<crate::models::Vlan, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vlans/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vrfs_create(
        &self,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vrfs_delete(&self, id: i32) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn ipam_vrfs_list(
        &self,
        name: Option<&str>,
        rd: Option<&str>,
        enforce_unique: Option<&str>,
        tenant_group_id: Option<&str>,
        tenant_group: Option<&str>,
        tenant_id: Option<&str>,
        tenant: Option<&str>,
        created: Option<&str>,
        created__gte: Option<&str>,
        created__lte: Option<&str>,
        last_updated: Option<&str>,
        last_updated__gte: Option<&str>,
        last_updated__lte: Option<&str>,
        id__in: Option<&str>,
        q: Option<&str>,
        tag: Option<&str>,
        name__n: Option<&str>,
        name__ic: Option<&str>,
        name__nic: Option<&str>,
        name__iew: Option<&str>,
        name__niew: Option<&str>,
        name__isw: Option<&str>,
        name__nisw: Option<&str>,
        name__ie: Option<&str>,
        name__nie: Option<&str>,
        rd__n: Option<&str>,
        rd__ic: Option<&str>,
        rd__nic: Option<&str>,
        rd__iew: Option<&str>,
        rd__niew: Option<&str>,
        rd__isw: Option<&str>,
        rd__nisw: Option<&str>,
        rd__ie: Option<&str>,
        rd__nie: Option<&str>,
        tenant_group_id__n: Option<&str>,
        tenant_group__n: Option<&str>,
        tenant_id__n: Option<&str>,
        tenant__n: Option<&str>,
        tag__n: Option<&str>,
        limit: Option<i32>,
        offset: Option<i32>,
    ) -> Result<crate::models::InlineResponse20051, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = rd {
            req_builder = req_builder.query(&[("rd", &s.to_string())]);
        }
        if let Some(ref s) = enforce_unique {
            req_builder = req_builder.query(&[("enforce_unique", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id {
            req_builder = req_builder.query(&[("tenant_group_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group {
            req_builder = req_builder.query(&[("tenant_group", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id {
            req_builder = req_builder.query(&[("tenant_id", &s.to_string())]);
        }
        if let Some(ref s) = tenant {
            req_builder = req_builder.query(&[("tenant", &s.to_string())]);
        }
        if let Some(ref s) = created {
            req_builder = req_builder.query(&[("created", &s.to_string())]);
        }
        if let Some(ref s) = created__gte {
            req_builder = req_builder.query(&[("created__gte", &s.to_string())]);
        }
        if let Some(ref s) = created__lte {
            req_builder = req_builder.query(&[("created__lte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated {
            req_builder = req_builder.query(&[("last_updated", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__gte {
            req_builder = req_builder.query(&[("last_updated__gte", &s.to_string())]);
        }
        if let Some(ref s) = last_updated__lte {
            req_builder = req_builder.query(&[("last_updated__lte", &s.to_string())]);
        }
        if let Some(ref s) = id__in {
            req_builder = req_builder.query(&[("id__in", &s.to_string())]);
        }
        if let Some(ref s) = q {
            req_builder = req_builder.query(&[("q", &s.to_string())]);
        }
        if let Some(ref s) = tag {
            req_builder = req_builder.query(&[("tag", &s.to_string())]);
        }
        if let Some(ref s) = name__n {
            req_builder = req_builder.query(&[("name__n", &s.to_string())]);
        }
        if let Some(ref s) = name__ic {
            req_builder = req_builder.query(&[("name__ic", &s.to_string())]);
        }
        if let Some(ref s) = name__nic {
            req_builder = req_builder.query(&[("name__nic", &s.to_string())]);
        }
        if let Some(ref s) = name__iew {
            req_builder = req_builder.query(&[("name__iew", &s.to_string())]);
        }
        if let Some(ref s) = name__niew {
            req_builder = req_builder.query(&[("name__niew", &s.to_string())]);
        }
        if let Some(ref s) = name__isw {
            req_builder = req_builder.query(&[("name__isw", &s.to_string())]);
        }
        if let Some(ref s) = name__nisw {
            req_builder = req_builder.query(&[("name__nisw", &s.to_string())]);
        }
        if let Some(ref s) = name__ie {
            req_builder = req_builder.query(&[("name__ie", &s.to_string())]);
        }
        if let Some(ref s) = name__nie {
            req_builder = req_builder.query(&[("name__nie", &s.to_string())]);
        }
        if let Some(ref s) = rd__n {
            req_builder = req_builder.query(&[("rd__n", &s.to_string())]);
        }
        if let Some(ref s) = rd__ic {
            req_builder = req_builder.query(&[("rd__ic", &s.to_string())]);
        }
        if let Some(ref s) = rd__nic {
            req_builder = req_builder.query(&[("rd__nic", &s.to_string())]);
        }
        if let Some(ref s) = rd__iew {
            req_builder = req_builder.query(&[("rd__iew", &s.to_string())]);
        }
        if let Some(ref s) = rd__niew {
            req_builder = req_builder.query(&[("rd__niew", &s.to_string())]);
        }
        if let Some(ref s) = rd__isw {
            req_builder = req_builder.query(&[("rd__isw", &s.to_string())]);
        }
        if let Some(ref s) = rd__nisw {
            req_builder = req_builder.query(&[("rd__nisw", &s.to_string())]);
        }
        if let Some(ref s) = rd__ie {
            req_builder = req_builder.query(&[("rd__ie", &s.to_string())]);
        }
        if let Some(ref s) = rd__nie {
            req_builder = req_builder.query(&[("rd__nie", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group_id__n {
            req_builder = req_builder.query(&[("tenant_group_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_group__n {
            req_builder = req_builder.query(&[("tenant_group__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id__n {
            req_builder = req_builder.query(&[("tenant_id__n", &s.to_string())]);
        }
        if let Some(ref s) = tenant__n {
            req_builder = req_builder.query(&[("tenant__n", &s.to_string())]);
        }
        if let Some(ref s) = tag__n {
            req_builder = req_builder.query(&[("tag__n", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = offset {
            req_builder = req_builder.query(&[("offset", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vrfs_partial_update(
        &self,
        id: i32,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vrfs_read(&self, id: i32) -> Result<crate::models::Vrf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn ipam_vrfs_update(
        &self,
        id: i32,
        data: crate::models::WritableVrf,
    ) -> Result<crate::models::Vrf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/ipam/vrfs/{id}/", configuration.base_path, id = id);
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("Authorization", val);
        };
        req_builder = req_builder.json(&data);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }
}
